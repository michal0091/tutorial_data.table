# La Sintaxis `DT[i, j, by]` 

::: {.callout-tip icon="false"}
## En este cap√≠tulo dominar√°s
- La estructura fundamental `DT[i, j, by]` 
- Filtrado avanzado de filas con `i`
- Selecci√≥n y transformaci√≥n de columnas con `j`
- Agrupaciones poderosas con `by`
- Combinaci√≥n efectiva de los tres componentes
:::

```{r}
#| label: setup-cap01-sintaxis
#| include: false

library(data.table)
library(ggplot2)
library(knitr)
library(DT)

# Configuraci√≥n
options(datatable.print.nrows = 8)
options(datatable.print.class = TRUE)

# Datos de ejemplo
set.seed(123)
empleados <- data.table(
  id = 1:12,
  nombre = c("Ana", "Juan", "Mar√≠a", "Carlos", "Luc√≠a", "Pedro", 
            "Isabel", "Miguel", "Carmen", "Jorge", "Laura", "Diego"),
  departamento = rep(c("Ventas", "IT", "Marketing", "RRHH"), each = 3),
  salario = c(35000, 42000, 38000, 50000, 45000, 55000,
             40000, 47000, 41000, 48000, 44000, 52000),
  a√±os_exp = c(2, 5, 3, 8, 6, 10, 4, 7, 3, 9, 5, 8),
  fecha_ingreso = as.Date(c("2022-01-15", "2019-03-10", "2021-07-01", 
                           "2015-09-20", "2018-11-05", "2013-04-12",
                           "2020-02-28", "2017-08-15", "2021-10-03",
                           "2014-12-01", "2019-06-18", "2016-01-25"))
)

# Dataset m√°s grande para ejemplos de performance
set.seed(456)
ventas <- data.table(
  id_venta = 1:50000,
  producto = sample(c("Laptop", "Mouse", "Teclado", "Monitor", "Tablet"), 50000, replace = TRUE),
  categoria = sample(c("Electr√≥nicos", "Accesorios", "Computadoras"), 50000, replace = TRUE),
  precio = round(runif(50000, 10, 2000), 2),
  cantidad = sample(1:10, 50000, replace = TRUE),
  fecha = sample(seq(as.Date("2020-01-01"), as.Date("2023-12-31"), by = "day"), 50000, replace = TRUE),
  vendedor_id = sample(1:100, 50000, replace = TRUE),
  region = sample(c("Norte", "Sur", "Este", "Oeste"), 50000, replace = TRUE)
)
```

## La Sintaxis `DT[i, j, by]`: El Coraz√≥n de `data.table`

Todo en `data.table` gira alrededor de esta estructura simple pero poderosa. Piensa en ella como una **pregunta en tres partes** que le haces a tus datos:

```{r}
#| label: estructura-basica
#| echo: true
#| eval: false

# La estructura universal
DT[i,           j,              by]
   ‚Üì            ‚Üì               ‚Üì
 ¬øD√≥nde?    ¬øQu√© hacer?    ¬øAgrupado por?
(filtros)   (seleccionar/   (variables de
           transformar)      agrupaci√≥n)
```

Cada componente es opcional, lo que hace la sintaxis extremadamente flexible.

## El Componente `i`: Selecci√≥n y Filtrado de Filas

### 1. **Filtrado B√°sico por Condiciones**

```{r}
#| label: filtrado-basico
#| echo: true

# Empleados con salario > 45000
empleados[salario > 45000]
```

```{r}
#| label: filtrado-multiple
#| echo: true

# M√∫ltiples condiciones: IT con m√°s de 5 a√±os de experiencia
empleados[departamento == "IT" & a√±os_exp > 5]
```

```{r}
#| label: filtrado-avanzado
#| echo: true

# Usando %in% para m√∫ltiples valores
empleados[departamento %in% c("Ventas", "Marketing")]
```

### 2. **Filtrado por Posici√≥n**

```{r}
#| label: filtrado-posicion
#| echo: true

# Primeras 3 filas
empleados[1:3]

# √öltima fila usando .N (n√∫mero total de filas)
empleados[.N]

# √öltimas 3 filas
empleados[(.N-2):.N]
```

### 3. **Filtrado por Orden**

```{r}
#| label: filtrado-orden
#| echo: true

# Ordenar por salario (ascendente)
empleados[order(salario)]

# Ordenar por salario descendente
empleados[order(-salario)]

# Ordenar por m√∫ltiples columnas
empleados[order(departamento, -salario)]
```

::: {.callout-tip}
## üí° Consejo: Filtrado Eficiente

`data.table` optimiza autom√°ticamente muchas operaciones de filtrado. Para datasets enormes, considera usar `setkey()` para acelerar filtros repetitivos (lo veremos en cap√≠tulos posteriores).
:::

## El Componente `j`: El Poder de la Transformaci√≥n

### 1. **Selecci√≥n Simple de Columnas**

```{r}
#| label: seleccion-simple
#| echo: true

# Seleccionar una columna (devuelve vector)
empleados[, salario]

# Seleccionar una columna (devolver data.table)
empleados[, .(salario)]

# M√∫ltiples columnas
empleados[, .(nombre, salario, departamento)]
```

### 2. **Creaci√≥n de Nuevas Columnas**

```{r}
#| label: columnas-nuevas
#| echo: true

# Crear columna calculada
empleados[, .(nombre, salario, salario_anual = salario * 12)]

# M√∫ltiples c√°lculos
empleados[, .(
  nombre,
  salario_mensual = salario,
  salario_anual = salario * 12,
  salario_por_a√±o_exp = round(salario / a√±os_exp, 0)
)]
```

### 3. **Funciones de Agregaci√≥n**

```{r}
#| label: agregacion-basica
#| echo: true

# Estad√≠sticas b√°sicas
empleados[, .(
  salario_promedio = mean(salario),
  salario_mediana = median(salario),
  salario_max = max(salario),
  salario_min = min(salario),
  total_empleados = .N
)]
```

### 4. **El S√≠mbolo Especial `.N`**

`.N` es una variable especial que representa el n√∫mero de filas en el grupo actual:

```{r}
#| label: simbolo-N
#| echo: true

# Contar total de filas
empleados[, .N]

# Contar empleados por departamento
empleados[, .N, by = departamento]

# Usar .N en c√°lculos
empleados[, .(
  empleados_total = .N,
  salario_promedio = mean(salario)
)]
```

## El Componente `by`: Agrupaciones Poderosas

### 1. **Agrupaci√≥n Simple**

```{r}
#| label: agrupacion-simple
#| echo: true

# Estad√≠sticas por departamento
empleados[, .(
  empleados = .N,
  salario_promedio = round(mean(salario), 0),
  salario_total = sum(salario)
), by = departamento]
```

### 2. **Agrupaci√≥n por M√∫ltiples Variables**

```{r}
#| label: agrupacion-multiple
#| echo: true

# Crear categor√≠as de experiencia para el ejemplo
empleados[, categoria_exp := ifelse(a√±os_exp <= 5, "Junior", "Senior")]

# Agrupar por departamento y categor√≠a de experiencia
empleados[, .(
  empleados = .N,
  salario_promedio = round(mean(salario), 0)
), by = .(departamento, categoria_exp)]
```

### 3. **Agrupaci√≥n con Expresiones**

```{r}
#| label: agrupacion-expresiones
#| echo: true

# Agrupar por rangos de salario calculados sobre la marcha
empleados[, .(
  empleados = .N,
  salario_promedio = round(mean(salario), 0)
), by = .(rango_salario = ifelse(salario > 45000, "Alto", "Medio-Bajo"))]
```

## Combinando los Tres Componentes

La verdadera potencia surge cuando combinas `i`, `j`, y `by`:

```{r}
#| label: combinacion-completa
#| echo: true

# Filtrar empleados con > 4 a√±os exp, calcular stats por departamento
empleados[a√±os_exp > 4, .(
  empleados_experimentados = .N,
  salario_promedio = round(mean(salario), 0),
  a√±os_exp_promedio = round(mean(a√±os_exp), 1)
), by = departamento]
```

## Ejercicios Pr√°cticos

::: {.callout-note icon="false"}
## üèãÔ∏è Ejercicio 1: Dominar la Sintaxis B√°sica

Usando el dataset `empleados`, resuelve:

1. **Filtrado**: Empleados de "Ventas" o "IT" con salario > 40000
2. **Agregaci√≥n**: Por cada departamento, calcula: empleados totales, salario promedio, y a√±os de experiencia m√°ximo
3. **Combinado**: Encuentra empleados con m√°s a√±os de experiencia que el promedio de su departamento
:::

::: {.callout-tip collapse="true"}
## üí° Soluci√≥n del Ejercicio 1

```{r}
#| label: solucion-ejercicio-1
#| echo: true

# 1. Filtrado avanzado
empleados_filtrados <- empleados[
  departamento %in% c("Ventas", "IT") & salario > 40000
]
print(empleados_filtrados)

# 2. Agregaci√≥n por departamento
stats_dept <- empleados[, .(
  total_empleados = .N,
  salario_promedio = round(mean(salario), 0),
  a√±os_exp_maximo = max(a√±os_exp)
), by = departamento]
print(stats_dept)

# 3. Empleados por encima del promedio de experiencia en su departamento
empleados_promedio_exp <- empleados[, exp_promedio_dept := mean(a√±os_exp), by = departamento][
  a√±os_exp > exp_promedio_dept, 
  .(nombre, departamento, a√±os_exp, exp_promedio_dept)
]
print(empleados_promedio_exp)
```
:::

## Patrones Comunes y Mejores Pr√°cticas

### 1. **Piensa en SQL**
Si conoces SQL, `data.table` te resultar√° familiar:

```{r}
#| label: paralelo-sql
#| echo: true
#| eval: false

# SQL: SELECT departamento, AVG(salario) FROM empleados WHERE salario > 40000 GROUP BY departamento
# data.table:
empleados[salario > 40000, .(salario_promedio = mean(salario)), by = departamento]
```

### 2. **Usa `.()` para M√∫ltiples Columnas**
`.()` es tu amigo para selecciones y c√°lculos m√∫ltiples:

```{r}
#| label: uso-punto-parentesis
#| echo: true

# ‚úÖ Correcto: m√∫ltiples columnas con nombres descriptivos
empleados[, .(
  empleado = nombre,
  dept = departamento,
  sueldo = salario,
  experiencia = a√±os_exp
)]
```

### 3. **Combina Operaciones de Forma Legible**
```{r}
#| label: operaciones-legibles
#| echo: true

# Ejemplo complejo pero legible
analisis_empleados <- empleados[
  a√±os_exp > 3,                     # i: filtrar por experiencia
  .(                                # j: calcular m√©tricas
    empleados = .N,
    salario_promedio = round(mean(salario), 0),
    experiencia_total = sum(a√±os_exp),
    salario_max = max(salario)
  ),
  by = departamento                 # by: agrupar por departamento
][order(-salario_promedio)]         # ordenar por salario desc

print(analisis_empleados)
```

## Comparaci√≥n de Performance

Veamos c√≥mo la sintaxis `data.table` se compara con alternativas:

```{r}
#| label: performance-sintaxis
#| echo: true
#| cache: true

# Preparar datos para comparaci√≥n
library(microbenchmark)
ventas_sample <- ventas[sample(.N, 10000)]  # Muestra para benchmark

# Comparar diferentes aproximaciones
benchmark_sintaxis <- microbenchmark(
  "data.table" = ventas_sample[precio > 100, .(avg_precio = mean(precio)), by = categoria],
  "base R" = aggregate(precio ~ categoria, ventas_sample[ventas_sample$precio > 100, ], mean),
  times = 20
)

print(benchmark_sintaxis)
```

## Pr√≥ximo Cap√≠tulo: S√≠mbolos Especiales

En el siguiente cap√≠tulo profundizaremos en:
- **`.SD`**: El subset de datos por grupo
- **`.SDcols`**: Control granular de columnas
- **`.I`** y **`.GRP`**: √çndices y identificadores de grupo
- Casos de uso avanzados de estos s√≠mbolos

---

::: {.callout-important}
## üéØ Puntos Clave de Este Cap√≠tulo

1. **`DT[i, j, by]`** es la sintaxis universal - dom√≠nala y dominar√°s `data.table`
2. **`i`** filtra filas - usa condiciones l√≥gicas, posiciones, u ordenamiento
3. **`j`** selecciona/calcula - usa `.()` para m√∫ltiples columnas con nombres
4. **`by`** agrupa datos - puede usar m√∫ltiples variables o expresiones
5. **`.N`** cuenta filas - funciona en contexto general o por grupo
6. **Combina libremente** - la flexibilidad es el superpoder de `data.table`
:::

Con estos fundamentos s√≥lidos de la sintaxis `DT[i, j, by]`, est√°s listo para explorar los s√≠mbolos especiales que hacen de `data.table` una herramienta verdaderamente poderosa.